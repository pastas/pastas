from logging import getLogger

from numpy import array, concatenate, exp, linspace, sqrt
from pandas import DataFrame, MultiIndex, Timedelta, concat
from scipy.stats import norm

logger = getLogger(__name__)


def _check_forecast_data(forecasts):
    """Internal method to check the integrity of the forecasts data.

    Parameters
    ----------
    forecasts: dict
        Dictionary containing the forecasts data. The keys are the stressmodel names
        and the values are lists of DataFrames containing the forecasts with a datetime
        index and each column a time series (i.e., one ensemble member).

    Returns
    -------
    n: int
        The number of ensemble members in the forecasts.
    tmin: datetime
        The minimum datetime in the forecasts.
    tmax: datetime
        The maximum datetime in the forecasts.
    index: DatetimeIndex
        The datetime index of the forecasts.

    Notes
    -----
    This method checks if the number of columns and indices are the same for all
    DataFrames in the forecasts dictionary. If the number of columns or the indices are
    not the same, a warning is printed and a ValueError is raised.

    """
    n = None
    tmax = None
    tmin = None
    index = None

    for fc_data in forecasts.values():
        for fc in fc_data:
            # Check if the number of columns is the same for all DataFrames
            if n is None:
                n = fc.columns.size
                tmin = fc.index[0]
                tmax = fc.index[-1]
                index = fc.index
            # If the number of columns is not the same, raise an error
            elif n != fc.columns.size:
                msg = (
                    "The number of ensemble members is not the same for all forecasts. "
                    "Please check the forecast data."
                )
                # logger.error(msg)
                raise ValueError(msg)
            elif tmin != fc.index[0] or tmax != fc.index[-1]:
                msg = (
                    "The time index of the forecasts is not the same for all forecasts."
                    "tmax Please check the forecast data."
                )
                # logger.error(msg)
                raise ValueError(msg)
            else:
                pass

    return n, tmin, tmax, index


def forecast(ml, forecasts, nparam=1, params=None, alpha=0.95, post_process=False):
    """Method to forecast the head from ensembles of stress forecasts.

    Parameters
    ----------
    ml: pastas.Model
        Pastas Model instance.
    forecasts: dict
        Dictionary containing the forecasts data. The keys are the stressmodel names
        and the values are lists of DataFrames containing the forecasts with a datetime
        index and each column a time series (i.e., one ensemble member).
    nparam: int, optional
        The number of parameters to generate. The first parameter set is the optimal
        parameter set of the model instance. The other parameter sets are generated by
        drawing parameters from a multivariate normal distribution. Default is 1. If
        nparam is 1, the optimal parameter set is used for the forecasts. This argument
        is only used if params is None.
    params: list, optional
        List of parameter sets to use for the forecasts. If None, parameter sets are
        generated using the solver of the model instance. Default is None.
    alpha: float, optional
        The confidence level to use for the prediction intervals. Default is 0.95.
    post_process: bool, optional
        If True, the forecasts are post-processed using the noise model of the model
        instance. Default is False. If True, a noise model should be present in the
        model instance. If no noisemodel is present and post_process is True, an error
        is raised.

    Returns
    -------
    df: pandas.DataFrame
        DataFrame containing the forecasts. The columns are a MultiIndex with the first
        level the ensemble member and the second level the parameter member.

    Notes
    -----

    1. iterate over the ensemble members
    2. iterate over the parameter sets
    3. generate the forecasts

    """
    # Copy the model so old model is unaffected.
    ml2 = ml.copy()

    # Check the integrity of the forecasts data
    n, tmin, tmax, index = _check_forecast_data(forecasts)

    if post_process and ml.noisemodel is None:
        msg = (
            "No noisemodel is present in the model instance. "
            "Please add a noisemodel to the model instance."
        )
        logger.error(msg)
        raise ValueError(msg)

    # Generate parameter sets
    if params is None:
        params = ml2.solver.get_parameter_sample(n=nparam)
    else:
        nparam = len(params)

    df_list = []

    # Generate forecasts with each ensemble member
    for m in range(n):
        # Update stresses with ensemble member data
        for sm_name, fc_data in forecasts.items():
            sm = ml2.stressmodels[sm_name]  # Select stressmodel
            for i, fc in enumerate(fc_data):
                ts = concat(
                    [
                        sm.stress[i].series_original.loc[: tmin - Timedelta(1, "D")],
                        fc.iloc[:, m],
                    ]
                )
                sm.stress[i].series_original = ts

        # Generate simulations for each parameter set
        for i, param in enumerate(params):
            # Generate the forecasts
            sim = ml2.simulate(tmin=tmin, tmax=tmax, p=param).values

            # Get the residuals
            res = ml2.residuals(tmax=tmin, p=param).dropna()

            # Compute the variance of the forecast error based on AR1 process
            if post_process:
                var = ml2.noise(p=param).var()
                phi = exp(-1 / param[-1])
                t = linspace(1, index.size, index.size)
                var = var * (1 - phi ** (2 * t)) / (1 - phi**2)
            else:
                var = res.var()

            # critical z value for the confidence interval based on alpha
            z = norm.ppf(1 - (1 - alpha) / 2)
            stderr = z * sqrt(var)

            # Store the results (mean, lower bound, upper bound)
            data = array([sim, sim - stderr, sim + stderr])

            # Compute the correction from the noise model
            if post_process:
                correction = ml2.noisemodel.get_correction(
                    res, [param[-1]], index
                ).values
                data = data + correction
            df_list.append(data)

    # Create DataFrames to store data
    mi = MultiIndex.from_product(
        [range(n), range(nparam), ["mean", "lower_bound", "upper_bound"]],
        names=["ensemble_member", "param_member", "forecast"],
    )
    df = DataFrame(data=concatenate(df_list).T, index=index, columns=mi, dtype=float)

    return df

